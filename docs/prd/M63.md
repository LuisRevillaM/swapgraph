# M63 â€” Rollout diagnostics lifecycle signals + stale-control alerts (fixtures-first)

## Objective
Strengthen operator remediation confidence by adding deterministic lifecycle telemetry and alerting to `partnerProgram.vault_export.rollout_policy.diagnostics.export`.

## Scope

### 1) Lifecycle telemetry in diagnostics exports
Add signed `lifecycle_signals` fields:
- `maintenance_mode_age_minutes`
- `freeze_window_remaining_minutes`
- `freeze_window_remaining_bucket` (`none|expired|critical|warning|stable`)

### 2) Deterministic diagnostics alerts
Add signed `alerts[]` projection from lifecycle state:
- `maintenance_mode_stale` when maintenance mode age exceeds threshold
- `freeze_window_expiring_soon` when active freeze window is within threshold

### 3) Threshold controls
Support query-level threshold controls:
- `maintenance_stale_after_minutes` (default 60)
- `freeze_expiring_soon_minutes` (default 15)

Invalid threshold values return deterministic contract errors with:
- `CONSTRAINT_VIOLATION`
- `reason_code=partner_rollout_diagnostics_threshold_invalid`

### 4) Continuity compatibility
Keep M62 diagnostics continuity controls and ensure signed attestation/checkpoint chaining still works with lifecycle/alerts included in export hash/signature.

### 5) Contract/docs artifacts
Update:
- diagnostics export schema (query threshold fields + lifecycle/alerts payloads)
- diagnostics API example
- API/ERROR docs for lifecycle alert behavior and threshold validation

### 6) Fixtures-first verifier
Scenario proves:
- stale-maintenance + freeze-expiring lifecycle detection
- deterministic alerts projection
- continuation chain validity with thresholds in query context
- post-clear lifecycle reset and empty alerts
- invalid threshold rejection reason code
- signature verification and tamper-fail behavior

## Acceptance criteria
- `npm run verify:m63` exits 0.
- `node verify/runner.ts milestones/M63.yaml` returns `overall=true`.
- artifacts exist under `artifacts/milestones/M63/latest/*`.
