# M34 — Delegation lifecycle APIs + revocation persistence

## Objective
Build on M32–M33 by adding **store-backed delegation lifecycle APIs** and proving that revocations are enforced **persistently** (not only when the client supplies an updated delegation object).

This keeps the system fixtures-first and deterministic.

## Scope

### 1) Delegation API contract
Add delegation endpoints to `docs/spec/api/manifest.v1.json` with schemas + examples:
- `POST /delegations` (`delegations.create`) — create a delegation grant
- `GET /delegations/{id}` (`delegations.get`) — fetch a delegation grant
- `POST /delegations/{id}/revoke` (`delegations.revoke`) — revoke a delegation grant

New request/response schemas:
- `DelegationCreateRequest/Response`
- `DelegationGetResponse`
- `DelegationRevokeRequest/Response`

Auth scopes:
- `delegations:read`
- `delegations:write`

### 2) Store-backed implementation
Add a store-backed service `src/service/delegationsService.mjs` that:
- stores grants under `store.state.delegations[delegation_id]`
- supports revoke as an idempotent state transition (`revoked_at` set once)

Update `src/store/jsonStateStore.mjs` to initialize/load `state.delegations`.

### 3) Revocation persistence enforcement
Update `src/core/authz.mjs` so that when `AUTHZ_ENFORCE=1` and `actor.type=agent`:
- revocation is enforced from the persisted store record (if present)
  - even if the caller continues presenting the original delegation object without `revoked_at`

### 4) Proof scenario
Add a deterministic proof scenario demonstrating:
1) user creates a delegation grant
2) agent can read with the returned grant
3) user revokes the grant
4) agent read fails with `UNAUTHORIZED` **even when using the original grant payload**

## Acceptance criteria
- `npm run verify:m34` exits 0.
- `node verify/runner.mjs milestones/M34.yaml` overall=true.
- Proof artifacts captured under `artifacts/milestones/M34/latest/*`.
