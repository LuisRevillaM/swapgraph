# M54 â€” Vault reconciliation export checkpoint retention + expiry hardening (fixtures-first)

## Objective
Prevent stale vault reconciliation export checkpoints from being reused indefinitely by adding deterministic checkpoint retention, expiry enforcement, and opportunistic garbage collection.

## Scope

### 1) Checkpoint retention window
For `settlement.vault_reconciliation.export` when checkpoint mode is enabled:
- add `SETTLEMENT_VAULT_EXPORT_CHECKPOINT_RETENTION_DAYS`
- checkpoints older than retention are expired
- default retention when unset/invalid is deterministic (`30` days)

### 2) Continuation expiry enforcement
When continuation is requested (`cursor_after` + `checkpoint_after`) under checkpoint mode:
- if checkpoint is expired, reject with:
  - `code=CONSTRAINT_VIOLATION`
  - `details.reason_code=checkpoint_expired`
- include machine-readable details:
  - `checkpoint_after`
  - `exported_at`
  - `now_iso`
  - `retention_days`

### 3) Opportunistic checkpoint GC
On successful export calls under checkpoint mode:
- prune expired checkpoint records from `settlement_vault_export_checkpoints`
- keep checkpoint state bounded and deterministic

### 4) Fixtures-first verifier
Scenario proves:
- old paginated checkpoint chain is initially valid,
- old continuation fails after retention window with `checkpoint_expired`,
- fresh checkpoint chain can be issued and continued,
- expired checkpoint records are removed while fresh checkpoints remain,
- tampered checkpoint payload still fails verification (`checkpoint_hash_mismatch`).

## Acceptance criteria
- `npm run verify:m54` exits 0.
- `node verify/runner.mjs milestones/M54.yaml` returns `overall=true`.
- artifacts exist under `artifacts/milestones/M54/latest/*`.
