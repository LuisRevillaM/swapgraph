# M102 — Commercial packaging and policy contracts (implemented, fixtures-first)

## Objective
Convert v2 monetization and packaging discovery outputs into deterministic commercial-policy contracts while preserving strict non-bypass trust/safety precedence.

## Scope
### A) Commercial policy contract set
1. `commercialPolicy.transaction_fee.get` → `GET /commercial/policies/transaction-fee`
2. `commercialPolicy.transaction_fee.upsert` → `POST /commercial/policies/transaction-fee`
3. `commercialPolicy.subscription_tier.get` → `GET /commercial/policies/subscription-tier`
4. `commercialPolicy.subscription_tier.upsert` → `POST /commercial/policies/subscription-tier`
5. `commercialPolicy.boost_policy.get` → `GET /commercial/policies/boost`
6. `commercialPolicy.boost_policy.upsert` → `POST /commercial/policies/boost`
7. `commercialPolicy.quota_policy.get` → `GET /commercial/policies/quota`
8. `commercialPolicy.quota_policy.upsert` → `POST /commercial/policies/quota`

### B) Policy evaluation and invariant contracts
1. `commercialPolicy.evaluate` → `POST /commercial/policies/evaluate`
2. Invariant enforcement guarantees:
   - commercial settings cannot bypass trust/risk gates
   - subscription upgrades cannot auto-unlock unsafe limits
   - boosting cannot violate matching/settlement constraints

### C) Audit/export contracts
1. `commercialPolicy.export` → `GET /commercial/policies/export`
   - signed policy export for partner/operator auditability
   - deterministic continuation + tamper-fail verification

## Contract map (approved and implemented)
| Operation ID | Method/Path | Idempotency | Actors | Scopes | Notes |
|---|---|---:|---|---|---|
| `commercialPolicy.transaction_fee.get` | `GET /commercial/policies/transaction-fee` | no | `partner` | `settlement:read` | effective fee policy read |
| `commercialPolicy.transaction_fee.upsert` | `POST /commercial/policies/transaction-fee` | yes | `partner` | `settlement:write` | policy mutation with audit |
| `commercialPolicy.subscription_tier.get` | `GET /commercial/policies/subscription-tier` | no | `partner` | `settlement:read` | tier/cap policy read |
| `commercialPolicy.subscription_tier.upsert` | `POST /commercial/policies/subscription-tier` | yes | `partner` | `settlement:write` | tier policy mutation |
| `commercialPolicy.boost_policy.get` | `GET /commercial/policies/boost` | no | `partner` | `settlement:read` | boost guardrail read |
| `commercialPolicy.boost_policy.upsert` | `POST /commercial/policies/boost` | yes | `partner` | `settlement:write` | boost guardrail mutation |
| `commercialPolicy.quota_policy.get` | `GET /commercial/policies/quota` | no | `partner` | `settlement:read` | quota/overage read |
| `commercialPolicy.quota_policy.upsert` | `POST /commercial/policies/quota` | yes | `partner` | `settlement:write` | quota/overage mutation |
| `commercialPolicy.evaluate` | `POST /commercial/policies/evaluate` | yes | `partner` | `settlement:write` | deterministic policy verdict |
| `commercialPolicy.export` | `GET /commercial/policies/export` | no | `partner` | `settlement:read` | signed policy export |

## Contract constraints
- Policy precedence is explicit and enforced: **safety > trust > commercial > user preference**.
- Commercial contracts are additive controls, never trust/safety bypass switches.
- All policy writes are idempotent and auditable.
- Export surfaces are signed and continuity-verifiable.

## Implemented schema artifacts
- `CommercialTransactionFeePolicyGetResponse.schema.json`
- `CommercialTransactionFeePolicyUpsertRequest.schema.json`
- `CommercialTransactionFeePolicyUpsertResponse.schema.json`
- `CommercialSubscriptionTierPolicyGetResponse.schema.json`
- `CommercialSubscriptionTierPolicyUpsertRequest.schema.json`
- `CommercialSubscriptionTierPolicyUpsertResponse.schema.json`
- `CommercialBoostPolicyGetResponse.schema.json`
- `CommercialBoostPolicyUpsertRequest.schema.json`
- `CommercialBoostPolicyUpsertResponse.schema.json`
- `CommercialQuotaPolicyGetResponse.schema.json`
- `CommercialQuotaPolicyUpsertRequest.schema.json`
- `CommercialQuotaPolicyUpsertResponse.schema.json`
- `CommercialPolicyEvaluateRequest.schema.json`
- `CommercialPolicyEvaluateResponse.schema.json`
- `CommercialPolicyExportResponse.schema.json`

## Deterministic reason-code floor (implemented)
- `commercial_policy_invalid`
- `commercial_policy_invalid_timestamp`
- `commercial_policy_precedence_violation`
- `commercial_policy_safety_bypass_denied`
- `commercial_policy_trust_gate_denied`
- `commercial_policy_boost_guardrail_denied`
- `commercial_policy_quota_exceeded`
- `commercial_policy_export_query_invalid`
- `commercial_policy_export_cursor_not_found`

## PRD review closure matrix
| Decision | Proposal | Status |
|---|---|---|
| Policy precedence | Enforce fixed precedence: safety > trust > commercial > preference | Approved + implemented |
| Boost boundaries | Boosts can affect ranking, never constraint/safety bypass | Approved + implemented |
| Subscription cap boundaries | Cap increases require trust milestones; subscription alone insufficient | Approved + implemented |
| Partner pricing visibility | Expose effective policy outputs, not full internal pricing internals | Approved + implemented |
| Export integrity | Signed export + continuation attestation/checkpoint required | Approved + implemented |
| Scope model | Reuse existing `settlement:read/write` scopes for first tranche | Approved + implemented (scope-migration gate retained pre-external rollout) |

## Non-goals (M102)
- No payment gateway implementation.
- No StoreKit entitlement implementation.
- No production pricing rollout.

## Acceptance (implementation stage)
- `npm run verify:m102` exits 0.
- `node verify/runner.mjs milestones/M102.yaml` returns `overall=true`.
- Artifacts under `artifacts/milestones/M102/latest/*`.
