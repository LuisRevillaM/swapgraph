# M69 â€” Rollout diagnostics automation attestation consistency verification (fixtures-first)

## Objective
Harden offline verification by enforcing deterministic internal consistency checks for signed rollout diagnostics automation attestation payloads.

## Scope

### 1) Verification consistency checks
Extend diagnostics export verification to validate that signed `automation_hints` are internally coherent:
- `plan_hash` recomputes from `source_alert_codes`, `action_queue`, `action_requests`, and `safety`
- `execution_attestation.expected_effect_hash` recomputes from ordered `action_requests[].expected_effect`
- `execution_attestation.request_hash_chain` recomputes from ordered `action_requests[].request_hash`
- `execution_attestation.policy_version_after_expected` matches projected tail version (or `policy_version_before` when empty)
- `execution_attestation.non_empty_action_plan` matches `action_requests.length > 0`
- `execution_attestation.attestation_hash` recomputes from `plan_hash` + execution attestation envelope
- `execution_attestation.policy_version_before` matches exported policy version

### 2) Public-key verifier parity
Apply the same consistency checks to both:
- default verifier path
- explicit public-key verifier path

### 3) Fixtures-first verifier coverage
Add scenario coverage proving:
- valid signed exports continue to verify
- re-signed payload with tampered `execution_attestation.expected_effect_hash` is rejected with deterministic mismatch reason
- existing hash tamper detection remains enforced

## Acceptance criteria
- `npm run verify:m69` exits 0.
- `node verify/runner.mjs milestones/M69.yaml` returns `overall=true`.
- artifacts exist under `artifacts/milestones/M69/latest/*`.
