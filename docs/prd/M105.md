# M105 — LP vault inventory and reservation lifecycle contracts (implemented, fixtures-first)

Status: Implemented and verifier-closed on 2026-02-22 (`npm run verify:m105`, `node verify/runner.mjs milestones/M105.yaml`).

## Objective
Extend existing vault/settlement contracts so LP inventory is guaranteed, auditable, and lifecycle-safe for listing, reservation, settlement, and unwind outcomes.

## Why this is required (integration findings)
- Vault holdings currently model `available|reserved|withdrawn` and settlement bindings.
- LP flows need explicit attribution + batch-safe reservation semantics.
- LP fulfillment guarantees depend on auditable inventory proofs and deterministic reservation behavior.

## Scope
### A) LP inventory contracts (implemented)
1. `liquidityInventory.snapshot.record` → `POST /liquidity-providers/{provider_id}/inventory/snapshots`
2. `liquidityInventory.assets.list` → `GET /liquidity-providers/{provider_id}/inventory/assets`
3. `liquidityInventory.availability.get` → `GET /liquidity-providers/{provider_id}/inventory/availability`

### B) LP reservation contracts (implemented)
1. `liquidityInventory.reserve.batch` → `POST /liquidity-providers/{provider_id}/inventory/reservations`
2. `liquidityInventory.release.batch` → `POST /liquidity-providers/{provider_id}/inventory/reservations/release`
3. `liquidityInventory.reconciliation.export` → `GET /liquidity-providers/{provider_id}/inventory/reconciliation/export`

### C) Lifecycle requirements
- Deterministic state progression for LP-listed assets:
  - `available -> reserved -> in_settlement -> released | refunded | withdrawn`
- One active reservation per asset across user + LP listings.
- Reservation ownership must map to provider and cycle context.
- Signed reconciliation export with continuation/tamper-fail verification.

## Integration bindings
- Reuse existing vault holding/settlement binding semantics as baseline.
- Add LP attribution to holding and reservation projections.
- Keep compatibility with current settlement timeline legs and reconciliation read surfaces.

## Schema artifacts (implemented)
- `LiquidityInventorySnapshotRecordRequest.schema.json`
- `LiquidityInventorySnapshotRecordResponse.schema.json`
- `LiquidityInventoryAssetListResponse.schema.json`
- `LiquidityInventoryAvailabilityGetResponse.schema.json`
- `LiquidityInventoryReservationBatchRequest.schema.json`
- `LiquidityInventoryReservationBatchResponse.schema.json`
- `LiquidityInventoryReleaseBatchRequest.schema.json`
- `LiquidityInventoryReleaseBatchResponse.schema.json`
- `LiquidityInventoryReconciliationExportResponse.schema.json`

## Deterministic reason-code floor (enforced)
- `liquidity_inventory_snapshot_invalid`
- `liquidity_inventory_asset_not_found`
- `liquidity_inventory_reservation_conflict`
- `liquidity_inventory_reservation_context_mismatch`
- `liquidity_inventory_not_available`
- `liquidity_inventory_reconciliation_query_invalid`

## Non-goals (M105)
- No change to cryptographic primitives.
- No production custody automation rollout.
- No UI-level inventory experiences.

## Acceptance (implementation stage)
- `npm run verify:m105` exits 0.
- `node verify/runner.mjs milestones/M105.yaml` returns `overall=true`.
- Artifacts under `artifacts/milestones/M105/latest/*`.
