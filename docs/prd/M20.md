# M20 — Commit APIs backed by stored proposals (accept/decline)

## Objective
Prove that Commit endpoints can be executed **from proposals stored in state**, not just in-memory fixtures.

Specifically:
- `cycleProposals.accept` loads the proposal from `store.state.proposals[proposal_id]`
- `cycleProposals.decline` loads the proposal from `store.state.proposals[proposal_id]`

This is still **fixtures-first** (no HTTP server), but models the real server behavior:
- proposals are persisted first
- commit operations reference proposal ids

## Inputs
- Seed proposals via delivery fixture polling response (`fixtures/delivery/m6_expected.json` → `polling_response.proposals[]`).
- Seed intents from `fixtures/matching/m5_input.json`.

## Rules (v1)
- `user` can accept/decline only if they are a participant in the proposal.
- `partner`/`agent` are forbidden (delegation comes later).
- Requests are idempotent via `Idempotency-Key` (fixtures model: explicit `idempotency_key`).
- If the proposal id does not exist in store: `NOT_FOUND`.

## Scope
- Add an API-level service that:
  - loads proposals from `store.state.proposals`
  - delegates to the existing `CommitService` for reservation + idempotency behavior
- Add a deterministic fixtures scenario that proves:
  - accept path progresses to `ready` when all participants accept
  - duplicate accepts replay idempotently
  - reservation conflicts still apply when a second proposal attempts to reserve the same intents
  - missing proposal id returns `NOT_FOUND`
  - all success/error bodies validate against the API manifest schemas

## Acceptance criteria
- `npm run verify:m20` exits 0.
- `node verify/runner.ts milestones/M20.yaml` exits 0.

## Required artifacts
- `docs/prd/M20.md`
- `fixtures/commit/m20_scenario.json`
- `fixtures/commit/m20_expected.json`
- `src/service/cycleProposalsCommitService.mjs`
- `scripts/run-m20-commit-from-store-scenario.mjs`
- Proof outputs under `artifacts/milestones/M20/latest/*`
